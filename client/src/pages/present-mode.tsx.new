import React, { useState, useEffect, useCallback, useRef } from "react";
import { Clock, ArrowRight, ArrowLeft, ArrowUp, ArrowDown, Image, Play, Volume2, VolumeX, Youtube } from "lucide-react";
import { useLocation, useRoute } from "wouter";
import screenfull from 'screenfull';
import { TooltipProvider, Tooltip, TooltipTrigger, TooltipContent } from "@/components/ui/tooltip";
import { Separator } from "@/components/ui/separator";
import { Skeleton } from "@/components/ui/skeleton";
import { Button } from "@/components/ui/button";
import { useProjects } from "@/hooks/use-projects";
import { useNotes } from "@/hooks/use-notes";
import { FullscreenToggle } from "@/components/ui/fullscreen-toggle";
import { ImageWithFallback } from "@/components/ui/image-with-fallback";
import { OverviewSlide } from "@/components/ui/overview-slide";
import { getTimeStyles, getTypographyStyles, generateTypographyStyles } from "@/lib/presentation-typography";
import { getThemeStyles, getBackgroundStyles } from "@/lib/presentation-themes";
import { timeToMinutes, formatPerSlideTime, formatTimeDifferenceHuman } from "@/lib/time-utils";

// Content type enum for rendering different types of content
enum ContentType {
  Regular,
  List,
  ShortList,
  Title,
  SubTitle,
  Quote,
  Code
}

interface PresentationNote extends Note {
  level?: number;
  rootIndex?: number; // Index of the root note this belongs to - for theming
  childNotes?: PresentationNote[]; // Direct child notes for overview slides
  hasChildren?: boolean; // Flag to indicate this note has children
  isOverviewSlide?: boolean; // Flag for chapter overview slides
  isStartSlide?: boolean; // Flag for project start slide
  isEndSlide?: boolean; // Flag for project end slide
  author?: string | null; // Author for end slides
  debugInfo?: string; // Debug information for development
  timeBorrowed?: boolean; // Flag to indicate time data was borrowed from another slide
}

interface PacingInfo {
  shouldShow: boolean;
  slideDifference: number;
  percentComplete: number;
  currenSlideIndex: number;
  previousTimedNote?: PresentationNote;
  nextTimedNote?: PresentationNote;
}

interface TimeSegment {
  lastPassedSlideIndex: number; // Index of the slide with the last passed time marker
  nextUpcomingSlideIndex: number | null; // Index of the slide with the next upcoming time marker
  lastPassedTime: string; // The time marker of the last passed slide
  nextUpcomingTime: string | null; // The time marker of the next upcoming slide
  currentProgress: number; // Progress between 0-1 indicating position between time points
}

interface TimeInfo {
  startTime: string;
  endTime: string;
  slideCount: number;
  totalMinutes: number;
  minutesPerSlide: number;
  formattedPerSlide: string;
}

// Helper function to determine content type from the note content
function determineContentType(content: string): ContentType {
  if (!content) return ContentType.Regular;
  
  const trimmedContent = content.trim();
  
  // Check for list-like content
  if (trimmedContent.split('\n').filter(line => line.trim()).length >= 3 && 
      trimmedContent.split('\n').filter(line => line.trim())
                 .every(line => line.trim().startsWith('-') || 
                               line.trim().startsWith('•') || 
                               line.trim().startsWith('*') ||
                               /^\d+\./.test(line.trim()))) {
    return ContentType.List;
  }
  
  // Check for short list (1-2 items)
  if (trimmedContent.split('\n').filter(line => line.trim()).length <= 2 && 
      trimmedContent.split('\n').filter(line => line.trim())
                 .every(line => line.trim().startsWith('-') || 
                               line.trim().startsWith('•') || 
                               line.trim().startsWith('*'))) {
    return ContentType.ShortList;
  }
  
  // Check for code/preformatted content
  if (trimmedContent.includes('```') || 
      (trimmedContent.includes('    ') && trimmedContent.includes('\n'))) {
    return ContentType.Code;
  }
  
  // Check for quote
  if (trimmedContent.startsWith('>') || 
      (trimmedContent.startsWith('"') && trimmedContent.endsWith('"'))) {
    return ContentType.Quote;
  }
  
  // Check for title (short & emphasized with ! or #)
  if ((trimmedContent.length < 60 && 
       (trimmedContent.includes('!') || trimmedContent.startsWith('#'))) ||
      (trimmedContent.length < 40 && !trimmedContent.includes('\n'))) {
    return ContentType.Title;
  }
  
  // Check for subtitle (slightly longer than title, may have formatting)
  if (trimmedContent.length < 100 && !trimmedContent.includes('\n')) {
    return ContentType.SubTitle;
  }
  
  // Default to regular content
  return ContentType.Regular;
}

// Helper function to format content based on its type
function formatContent(content: string): React.ReactNode {
  if (!content) return null;
  
  // Handle lists
  if (content.includes('\n') && content.split('\n').some(line => 
      line.trim().startsWith('-') || 
      line.trim().startsWith('•') || 
      line.trim().startsWith('*'))) {
    return (
      <ul className="list-disc list-inside text-left space-y-1">
        {content.split('\n')
          .filter(line => line.trim())
          .map((line, idx) => {
            // Remove the list marker
            const cleanLine = line.trim().replace(/^[-•*]\s*/, '');
            // If line already has a list marker, we use it directly
            return <li key={idx} dangerouslySetInnerHTML={{ __html: cleanLine }} />;
          })}
      </ul>
    );
  }
  
  // Handle numbered lists
  if (content.includes('\n') && content.split('\n').some(line => 
      /^\d+\./.test(line.trim()))) {
    return (
      <ol className="list-decimal list-inside text-left space-y-1">
        {content.split('\n')
          .filter(line => line.trim())
          .map((line, idx) => {
            // Remove the list marker
            const cleanLine = line.trim().replace(/^\d+\.\s*/, '');
            return <li key={idx} dangerouslySetInnerHTML={{ __html: cleanLine }} />;
          })}
      </ol>
    );
  }
  
  // Handle special formatting
  return <div dangerouslySetInnerHTML={{ __html: content }} />;
}

// Function to calculate time info for a segment
function calculateTimeInfo(
  notes: PresentationNote[], 
  currentNoteId: number,
  notesIds: number[]
): TimeInfo | null {
  // Find current note index in flattened structure
  const currentIndex = notesIds.indexOf(currentNoteId);
  if (currentIndex < 0) return null;
  
  // Get current note
  const currentNote = notes.find(n => n.id === currentNoteId);
  if (!currentNote || !currentNote.time) return null;
  
  // Find next timed note
  let nextTimedIndex = -1;
  let nextTimedNote: PresentationNote | undefined;
  
  for (let i = currentIndex + 1; i < notesIds.length; i++) {
    const noteId = notesIds[i];
    const note = notes.find(n => n.id === noteId);
    if (note?.time) {
      nextTimedIndex = i;
      nextTimedNote = note;
      break;
    }
  }
  
  if (!nextTimedNote || !nextTimedNote.time) return null;
  
  // Calculate time allocation info
  const startTime = currentNote.time;
  const endTime = nextTimedNote.time;
  const slideCount = nextTimedIndex - currentIndex;
  
  // Calculate total minutes
  const startMin = timeToMinutes(startTime);
  const endMin = timeToMinutes(endTime);
  let totalMin = endMin - startMin;
  if (totalMin < 0) totalMin += 24 * 60; // Adjust for time wrapping to next day
  
  // Calculate time per slide 
  const minutesPerSlide = slideCount > 0 ? totalMin / slideCount : 0; 
  
  return {
    startTime,
    endTime,
    slideCount,
    totalMinutes: Math.round(totalMin),
    minutesPerSlide,
    formattedPerSlide: formatPerSlideTime(minutesPerSlide)
  };
}

export default function PresentMode() {
  const [match, params] = useRoute<{ projectId?: string, noteId?: string }>('/present/:projectId/:noteId?');
  const [, setLocation] = useLocation();
  const [currentSlideIndex, setCurrentSlideIndex] = useState<number>(0);
  const [lastViewedSlideIndex, setLastViewedSlideIndex] = useState<number>(0);
  const [flattenedNotes, setFlattenedNotes] = useState<PresentationNote[]>([]);
  const [isFullscreen, setIsFullscreen] = useState<boolean>(false);
  const [showThumbnails, setShowThumbnails] = useState<boolean>(false);
  const [isMuted, setIsMuted] = useState<boolean>(true);
  const [showGrid, setShowGrid] = useState<boolean>(false);
  const [debugMode, setDebugMode] = useState<boolean>(false);
  const [pacingInfo, setPacingInfo] = useState<PacingInfo>({
    shouldShow: false,
    slideDifference: 0,
    percentComplete: 0,
    currenSlideIndex: 0,
  });
  const [currentSettings, setCurrentSettings] = useState({
    fontSize: 100, // 100% is default
    colorMode: 'auto', // auto, light, dark
  });
  
  // Refs for various elements
  const videoRef = useRef<HTMLIFrameElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const slideContainerRef = useRef<HTMLDivElement>(null);
  
  const pacingTimerRef = useRef<NodeJS.Timeout | null>(null);
  
  // Get project and note data
  const projectId = params?.projectId ? parseInt(params.projectId) : undefined;
  const startNoteId = params?.noteId ? parseInt(params.noteId) : undefined;
  
  const { getProject, isLoading: isProjectLoading, updateLastViewedSlideIndex } = useProjects();
  const { getNotes, isLoading: isNotesLoading } = useNotes();
  
  const currentProject = projectId ? getProject(projectId) : undefined;
  const projectNotes = projectId ? getNotes(projectId) : [];
  
  const isLoading = isProjectLoading || isNotesLoading || !currentProject;
  
  // Current note is the active slide
  const currentNote = flattenedNotes[currentSlideIndex];
  const isOverviewSlide = currentNote?.isOverviewSlide;
  const isStartSlide = currentNote?.isStartSlide;
  const isEndSlide = currentNote?.isEndSlide;
  
  // Level determines the theme (inheritance from parent headings)
  const level = currentNote?.level || 0;
  
  // Root index determines the color theme for a section
  const rootIndex = currentNote?.rootIndex !== undefined ? currentNote.rootIndex : 0;
  
  // Initialize presentation
  useEffect(() => {
    console.log("PRESENT MODE COMPONENT LOADED");
    
    // If no projectId, exit early
    if (!projectId) return;
    
    // Setup fullscreen change handler
    const handleFullscreenChange = () => {
      setIsFullscreen(Boolean(document.fullscreenElement));
    };
    
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    
    // Clean up
    return () => {
      document.removeEventListener('fullscreenchange', handleFullscreenChange);
      
      // Clean up the pacing interval timer
      if (pacingTimerRef.current) {
        console.log("Cleaning up pacing interval timer");
        clearInterval(pacingTimerRef.current);
        pacingTimerRef.current = null;
      }
    };
  }, [projectId]);
  
  // Process notes for presentation format
  useEffect(() => {
    if (!projectId || !projectNotes || projectNotes.length === 0) return;
    
    const formattedNotes: PresentationNote[] = [];
    
    // Step 1: Add a start/title slide if project info exists
    const startSlide: PresentationNote = {
      id: -100, // Use negative ID to avoid conflicts
      content: currentProject?.name || "Project",
      projectId: projectId,
      parentId: null,
      images: [],
      order: "-1", // Always first
      level: 0,
      rootIndex: 0, // Start slide is root 0
      isStartSlide: true,
      time: null, // Will be borrowed from the first timed slide
      timeBorrowed: true,
    };
    
    // Add project info slide
    formattedNotes.push(startSlide);
    
    // Step 2: Create a nodes map for easy lookup and set root notes
    const notesMap = new Map<number, PresentationNote>();
    const rootNotes: PresentationNote[] = [];
    
    // Map parent-child relationships and identify root notes
    projectNotes.forEach(note => {
      const presentationNote: PresentationNote = {
        ...note,
        level: 0, // Will be calculated below
        images: note.images || [],
      };
      notesMap.set(note.id, presentationNote);
      
      if (note.parentId === null) {
        rootNotes.push(presentationNote);
      }
    });
    
    // Step 3: Calculate levels and root indexes for each note
    let currentRootIndex = 0;
    
    // For each root note, walk its tree and add to flattened list
    rootNotes.sort((a, b) => {
      const aOrder = parseFloat(String(a.order));
      const bOrder = parseFloat(String(b.order));
      return aOrder - bOrder;
    }).forEach(rootNote => {
      // Add the root note and all its children recursively
      const addNoteAndChildren = (note: PresentationNote, currentRootIndex: number) => {
        // Set the root index and level
        note.rootIndex = currentRootIndex;
        
        // Check if note has children
        const children = projectNotes.filter(n => n.parentId === note.id);
        note.hasChildren = children.length > 0;
        
        // If this is a "root" node with children, add an overview slide before it
        if (note.parentId === null && children.length > 0) {
          // Create an overview slide showing the section title + children as list
          const overviewSlide: PresentationNote = {
            id: -200 - currentRootIndex, // Use negative ID to avoid conflicts
            content: `# ${note.content}`,
            projectId: projectId,
            parentId: null,
            images: [],
            order: String(parseFloat(String(note.order)) - 0.5), // Just before the section
            level: 0,
            rootIndex: currentRootIndex,
            isOverviewSlide: true,
            childNotes: children.map(child => ({ ...child, level: 1 })),
            time: note.time, // Borrow time from the section heading if available
            timeBorrowed: !!note.time,
          };
          
          // Add overview slide before the section
          formattedNotes.push(overviewSlide);
        }
        
        // Add this note
        formattedNotes.push(note);
        
        // Add all children recursively with increased level
        if (children.length > 0) {
          // Sort children by order before adding
          children.sort((a, b) => {
            const aOrder = parseFloat(String(a.order));
            const bOrder = parseFloat(String(b.order));
            return aOrder - bOrder;
          }).forEach(child => {
            const childNote = notesMap.get(child.id);
            if (childNote) {
              // Set child level based on parent
              childNote.level = (note.level || 0) + 1;
              // Recursively add this child and its children
              addNoteAndChildren(childNote, currentRootIndex);
            }
          });
        }
      };
      
      // Add the root note and all its children
      addNoteAndChildren(rootNote, currentRootIndex);
      
      // Increment root index for the next root note
      currentRootIndex++;
    });
    
    // Step 4: Add end slide
    const endSlide: PresentationNote = {
      id: -101, // Use negative ID to avoid conflicts
      content: currentProject?.name || "Thank You!",
      projectId: projectId,
      parentId: null,
      images: [],
      order: "999999", // Always last
      level: 0,
      rootIndex: 0, // End slide uses first theme
      isEndSlide: true,
      author: currentProject?.author || null,
      time: null, // Will be borrowed in a later step
      timeBorrowed: true,
    };
    
    // Add end slide
    formattedNotes.push(endSlide);
    
    // Step 5: Determine time borrowing - "borrow" time values from nearby slides if start/end doesn't have one
    // First, find first slide with time value
    const firstTimedSlide = formattedNotes.find(note => note.time && !note.timeBorrowed);
    const lastTimedSlide = [...formattedNotes].reverse().find(note => note.time && !note.timeBorrowed);
    
    // If start slide doesn't have time but there's a first timed slide, borrow its time
    if (startSlide.timeBorrowed && firstTimedSlide?.time) {
      const startSlideIndex = formattedNotes.findIndex(n => n.id === startSlide.id);
      if (startSlideIndex >= 0) {
        formattedNotes[startSlideIndex].time = firstTimedSlide.time;
        formattedNotes[startSlideIndex].timeBorrowed = true;
      }
    }
    
    // If end slide doesn't have time but there's a last timed slide, borrow its time
    if (endSlide.timeBorrowed && lastTimedSlide?.time) {
      const endSlideIndex = formattedNotes.findIndex(n => n.id === endSlide.id);
      if (endSlideIndex >= 0) {
        formattedNotes[endSlideIndex].time = lastTimedSlide.time;
        formattedNotes[endSlideIndex].timeBorrowed = true;
      }
    }
    
    // Use start note ID if provided, otherwise use first slide
    if (startNoteId) {
      const startIndex = formattedNotes.findIndex(note => note.id === startNoteId);
      if (startIndex >= 0) {
        setCurrentSlideIndex(startIndex);
        console.log("Starting presentation from note ID:", startNoteId, "at index:", startIndex);
      } else {
        console.log("Starting presentation from beginning (specific note not found)");
        setCurrentSlideIndex(0);
      }
    } else {
      console.log("Starting presentation from beginning");
      setCurrentSlideIndex(0);
    }
    
    // Set the flattened notes
    setFlattenedNotes(formattedNotes);
    
    // Set up pacing interval timer
    pacingTimerRef.current = setInterval(() => {
      // Find timed notes for this slide
      updatePacingInfo();
    }, 1000);
    console.log("Setting up pacing interval timer");
    
    // Start the presentation
    console.log("Starting presentation from beginning");
    
    // Find all timed notes to display a log
    const timedNotes = formattedNotes.filter(note => note.time).map((note, index) => ({
      id: note.id,
      time: note.time,
      content: note.content?.substring(0, 30) + "...",
      index
    }));
    console.log("Found", timedNotes.length, "timed notes in presentation:", timedNotes);
    
    return () => {
      // Clean up the pacing interval timer
      if (pacingTimerRef.current) {
        console.log("Cleaning up pacing interval timer");
        clearInterval(pacingTimerRef.current);
        pacingTimerRef.current = null;
      }
    };
  }, [projectId, projectNotes, currentProject, startNoteId]);
  
  // Determine if a note is a "major" slide (section heading or special slide)
  const isMajorSlide = (note: PresentationNote): boolean => 
    note.parentId === null || note.isOverviewSlide || note.isStartSlide || note.isEndSlide;
  
  // Navigate through slides
  const navigateToSlide = (index: number) => {
    if (index < 0 || index >= flattenedNotes.length) return;
    setCurrentSlideIndex(index);
    
    // Update last viewed slide on server
    if (projectId) {
      updateLastViewedSlideIndex(projectId, index).catch(console.error);
    }
  };
  
  // Navigate to next slide
  const goToNextSlide = () => {
    navigateToSlide(currentSlideIndex + 1);
  };
  
  // Navigate to previous slide
  const goToPrevSlide = () => {
    navigateToSlide(currentSlideIndex - 1);
  };
  
  // Navigate to next major slide (section)
  const goToNextSection = () => {
    for (let i = currentSlideIndex + 1; i < flattenedNotes.length; i++) {
      if (isMajorSlide(flattenedNotes[i])) {
        navigateToSlide(i);
        return;
      }
    }
    // If no next section, go to last slide
    navigateToSlide(flattenedNotes.length - 1);
  };
  
  // Navigate to previous major slide (section)
  const goToPrevSection = () => {
    for (let i = currentSlideIndex - 1; i >= 0; i--) {
      if (isMajorSlide(flattenedNotes[i])) {
        navigateToSlide(i);
        return;
      }
    }
    // If no previous section, go to first slide
    navigateToSlide(0);
  };
  
  // Exit presentation
  const exitPresentation = useCallback((noteId?: number) => {
    if (pacingTimerRef.current) {
      console.log("Exiting presentation to home" + (noteId ? ` (note ${noteId})` : " (no specific note)"));
      console.log("Cleaning up pacing interval timer");
      clearInterval(pacingTimerRef.current);
      pacingTimerRef.current = null;
    }
    
    // Exit fullscreen first if active
    if (document.fullscreenElement && screenfull.isEnabled) {
      screenfull.exit();
    }
    
    // Navigate back to project or specific note
    if (projectId) {
      if (noteId) {
        setLocation(`/project/${projectId}/note/${noteId}`);
      } else {
        setLocation(`/project/${projectId}`);
      }
    } else {
      setLocation('/');
    }
  }, [projectId, setLocation]);
  
  // Toggle fullscreen mode
  const toggleFullscreen = () => {
    if (containerRef.current) {
      if (!document.fullscreenElement && screenfull.isEnabled) {
        screenfull.request(containerRef.current);
      } else if (screenfull.isEnabled) {
        screenfull.exit();
      }
    }
  };
  
  // Handle keyboard navigation
  const handleKeyDown = (e: KeyboardEvent) => {
    // Ignore key presses when modal dialogs are open
    const modalOpen = document.querySelector('[role="dialog"]');
    if (modalOpen) return;
    
    // Ignore key presses in input fields
    if (['INPUT', 'TEXTAREA'].includes((e.target as HTMLElement)?.tagName)) return;
    
    switch (e.key) {
      case ' ':
      case 'ArrowRight':
      case 'PageDown':
        e.preventDefault();
        goToNextSlide();
        break;
      case 'Backspace':
      case 'ArrowLeft':
      case 'PageUp':
        e.preventDefault();
        goToPrevSlide();
        break;
      case 'ArrowUp':
      case 'Home':
        e.preventDefault();
        goToPrevSection();
        break;
      case 'ArrowDown':
      case 'End':
        e.preventDefault();
        goToNextSection();
        break;
      case 'Escape':
        e.preventDefault();
        exitPresentation();
        break;
      case 'f':
        e.preventDefault();
        toggleFullscreen();
        break;
      case 't':
        e.preventDefault();
        setShowThumbnails(prev => !prev);
        break;
      case 'm':
        e.preventDefault();
        setIsMuted(prev => !prev);
        break;
      case 'g':
        e.preventDefault();
        setShowGrid(prev => !prev);
        break;
      case 'd':
        e.preventDefault();
        setDebugMode(prev => !prev);
        break;
    }
  };
  
  // Add keyboard event listener
  useEffect(() => {
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [currentSlideIndex, flattenedNotes.length, handleKeyDown]);
  
  // Function to get the next timed slide (if any)
  const getNextTimedSlide = useCallback((): PresentationNote | null => {
    for (let i = currentSlideIndex + 1; i < flattenedNotes.length; i++) {
      if (flattenedNotes[i].time && !flattenedNotes[i].timeBorrowed) {
        return flattenedNotes[i];
      }
    }
    return null;
  }, [currentSlideIndex, flattenedNotes]);
  
  // Function to update pacing information
  const updatePacingInfo = useCallback(() => {
    if (!currentNote || flattenedNotes.length === 0) {
      return;
    }
    
    const now = new Date();
    console.log("Updating pacing info at", now.toISOString());
    
    // Find previous and next timed notes
    let previousTimedNote: PresentationNote | undefined;
    let nextTimedNote: PresentationNote | undefined;
    
    // Find previous timed note (excluding borrowed)
    for (let i = currentSlideIndex; i >= 0; i--) {
      if (flattenedNotes[i].time && !flattenedNotes[i].timeBorrowed) {
        previousTimedNote = flattenedNotes[i];
        break;
      }
    }
    
    // Find next timed note (excluding borrowed)
    for (let i = currentSlideIndex + 1; i < flattenedNotes.length; i++) {
      if (flattenedNotes[i].time && !flattenedNotes[i].timeBorrowed) {
        nextTimedNote = flattenedNotes[i];
        break;
      }
    }
    
    // Calculate timing information if we have both prev and next notes
    if (previousTimedNote && nextTimedNote) {
      // Get indices to calculate slide difference
      const prevIndex = flattenedNotes.findIndex(n => n.id === previousTimedNote?.id);
      const nextIndex = flattenedNotes.findIndex(n => n.id === nextTimedNote?.id);
      
      if (prevIndex >= 0 && nextIndex >= 0) {
        // Calculate total slides between time points
        const totalSlides = nextIndex - prevIndex;
        
        // Calculate our progress (which slide are we on between time points)
        const slidesFromPrev = currentSlideIndex - prevIndex;
        const percentComplete = totalSlides > 0 ? slidesFromPrev / totalSlides : 0;
        
        // Calculate where we "should" be based on current time
        const prevTimeInMinutes = timeToMinutes(previousTimedNote.time || '');
        const nextTimeInMinutes = timeToMinutes(nextTimedNote.time || '');
        
        // Get current time in minutes
        const currentHour = now.getHours();
        const currentMinute = now.getMinutes();
        const currentTimeInMinutes = currentHour * 60 + currentMinute;
        
        // Calculate total time span
        let totalTimeSpan = nextTimeInMinutes - prevTimeInMinutes;
        if (totalTimeSpan < 0) totalTimeSpan += 24 * 60; // Handle crossing midnight
        
        // Calculate where we should be in the slides timeline based on time
        const timeProgress = (currentTimeInMinutes - prevTimeInMinutes) / totalTimeSpan;
        const expectedSlidePosition = prevIndex + Math.round(timeProgress * totalSlides);
        
        // Calculate slide difference (positive = ahead, negative = behind)
        const slideDifference = currentSlideIndex - expectedSlidePosition;
        
        // Update pacing info
        setPacingInfo({
          shouldShow: true,
          slideDifference,
          percentComplete,
          currenSlideIndex: currentSlideIndex,
          previousTimedNote,
          nextTimedNote,
        });
        
        console.log("New pacing info:", {
          shouldShow: true,
          slideDifference,
          percentComplete,
          currenSlideIndex: currentSlideIndex
        });
        return;
      }
    }
    
    // If we don't have both prev and next, show simpler info
    setPacingInfo({
      shouldShow: false,
      slideDifference: 0,
      percentComplete: 0,
      currenSlideIndex: currentSlideIndex,
      previousTimedNote,
      nextTimedNote,
    });
    
    console.log("New pacing info:", {
      shouldShow: false,
      slideDifference: 0,
      percentComplete: 0,
      currenSlideIndex: currentSlideIndex
    });
  }, [currentNote, currentSlideIndex, flattenedNotes]);
  
  // Find the ancestor path for a note
  const findAncestorPath = (note: PresentationNote, notesMap: Map<number, PresentationNote>): React.ReactNode => {
    if (!note.parentId) return null;
    
    const ancestors: PresentationNote[] = [];
    let parentId = note.parentId;
    
    // Build ancestor chain
    while (parentId) {
      const parent = notesMap.get(parentId);
      if (parent) {
        ancestors.unshift(parent);
        parentId = parent.parentId;
      } else {
        break;
      }
    }
    
    // Skip showing path if only one level deep
    if (ancestors.length === 0) return null;
    
    return (
      <div className="text-xs opacity-60 mb-2 font-light">
        {ancestors.map((ancestor, idx) => (
          <React.Fragment key={ancestor.id}>
            <span className="hover:underline cursor-pointer" 
                  onClick={() => {
                    const index = flattenedNotes.findIndex(n => n.id === ancestor.id);
                    if (index >= 0) navigateToSlide(index);
                  }}>
              {ancestor.content.substring(0, 25)}
              {ancestor.content.length > 25 ? '...' : ''}
            </span>
            {idx < ancestors.length - 1 && 
              <span className="mx-1">›</span>
            }
          </React.Fragment>
        ))}
      </div>
    );
  };
  
  // Find the root index for a note (for consistent theming)
  const findRootIndex = (note: PresentationNote): number => {
    if (note.rootIndex !== undefined) return note.rootIndex;
    
    // Special slides get default root index 0
    if (note.isStartSlide || note.isEndSlide || note.isOverviewSlide) {
      return 0;
    }
    
    // If no explicit root index is set, use the position in the flattened array
    // to assign a consistent theme for each 5-10 slides
    return Math.floor(currentSlideIndex / 10) % 5;
  };
  
  // Loading state
  if (isLoading) {
    return (
      <div className="w-full h-screen bg-black flex items-center justify-center">
        <div className="text-white text-center">
          <Skeleton className="h-12 w-48 bg-gray-800 mb-4" />
          <Skeleton className="h-4 w-64 bg-gray-800 mb-2" />
          <Skeleton className="h-4 w-52 bg-gray-800" />
        </div>
      </div>
    );
  }
  
  // Component to render YouTube embed
  const renderYouTubeEmbed = (youtubeLink: string, { autoplay = false, startTime = null }: { autoplay?: boolean, startTime?: string | null }) => {
    let embedUrl = youtubeLink;
    
    // Convert standard YouTube URL to embed URL if needed
    if (youtubeLink.includes('youtube.com/watch')) {
      const urlObj = new URL(youtubeLink);
      const videoId = urlObj.searchParams.get('v');
      embedUrl = `https://www.youtube.com/embed/${videoId}`;
      
      // Add parameters
      const params = new URLSearchParams();
      
      // Always add these defaults
      params.append('rel', '0');
      params.append('showinfo', '0');
      
      // Add autoplay if requested
      if (autoplay) {
        params.append('autoplay', '1');
      }
      
      // Add mute state
      params.append('mute', isMuted ? '1' : '0');
      
      // Add start time if provided
      if (startTime) {
        params.append('start', convertTimeToSeconds(startTime).toString());
      }
      
      // Append parameters to URL
      embedUrl += `?${params.toString()}`;
    }
    
    return (
      <div className="aspect-video w-full h-full max-h-[75vh] rounded-lg overflow-hidden shadow-2xl">
        <iframe
          ref={videoRef}
          src={embedUrl}
          title="YouTube video player"
          frameBorder="0"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
          allowFullScreen
          className="w-full h-full"
        ></iframe>
      </div>
    );
  };
  
  // If we don't have a valid project, show error
  if (!currentProject) {
    return (
      <div className="w-full h-screen bg-black flex flex-col items-center justify-center text-white p-4">
        <h2 className="text-2xl mb-4">Project not found</h2>
        <p className="mb-6">The requested project could not be loaded.</p>
        <Button onClick={() => setLocation('/')}>
          Return to Home
        </Button>
      </div>
    );
  }
  
  // Main presentation view
  return (
    <div 
      ref={containerRef}
      className="bg-black text-white flex flex-col w-full h-screen overflow-hidden relative" 
      onClick={() => goToNextSlide()}
      onDoubleClick={toggleFullscreen}
    >
      <div className="flex-1 flex items-center justify-center relative">
        {flattenedNotes.length > 0 && (
          <div
            ref={slideContainerRef}
            style={{
              ...getBackgroundStyles(findRootIndex(currentNote), level),
              width: "100%",
              height: "100%",
              position: "relative",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              overflow: "hidden",
            }}
          >
            {/* Optional grid overlay for debugging */}
            {showGrid && (
              <div 
                className="absolute top-0 left-0 right-0 bottom-0 bg-transparent pointer-events-none z-10"
                style={{
                  backgroundImage: `
                    linear-gradient(to right, rgba(255,255,255,0.05) 1px, transparent 1px),
                    linear-gradient(to bottom, rgba(255,255,255,0.05) 1px, transparent 1px)
                  `,
                  backgroundSize: '100px 100px',
                }}
              />
            )}
            
            {/* Current slide content */}
            {currentNote && (
              <div className="w-full h-full overflow-hidden flex items-center justify-center relative slide-container">
                {/* For overview slides, render a special layout */}
                {isOverviewSlide ? (
                  <OverviewSlide 
                    slide={currentNote} 
                    navigateToSlide={navigateToSlide}
                    flattenedNotes={flattenedNotes}
                  />
                ) : isStartSlide ? (
                  // Title slide
                  <div className="w-full h-full flex flex-col items-center justify-center p-4 md:p-8">
                    <div className="start-slide mb-auto"></div>
                    <div className="flex-1 flex flex-col items-center justify-center max-w-5xl w-full">
                      <h1 
                        className="text-4xl sm:text-5xl md:text-6xl font-bold mb-6 text-center" 
                        style={getThemeStyles(findRootIndex(currentNote), level)}
                      >
                        {currentNote.content}
                      </h1>
                      
                      {currentProject.startSlogan && (
                        <h2 className="text-xl sm:text-2xl md:text-3xl opacity-80 mb-8 text-center">
                          {currentProject.startSlogan}
                        </h2>
                      )}
                      
                      {currentProject.author && (
                        <div className="mt-6 text-lg sm:text-xl opacity-70">
                          By {currentProject.author}
                        </div>
                      )}
                      
                      {currentNote.time && (
                        <div className="mt-8 bg-black/30 px-4 py-2 rounded-full">
                          <Clock className="inline mr-2" />
                          <span className="font-mono">
                            {currentNote.time}
                            {currentNote.timeBorrowed && (
                              <span className="ml-1 text-yellow-400 text-sm">(borrowed)</span>
                            )}
                          </span>
                        </div>
                      )}
                    </div>
                    <div className="mt-auto text-sm opacity-50">
                      {/* Additional start slide footer info if needed */}
                    </div>
                  </div>
                ) : isEndSlide ? (
                  // End/Thank you slide
                  <div className="w-full h-full flex flex-col items-center justify-center p-4 md:p-8">
                    <div className="flex-1 flex flex-col items-center justify-center max-w-5xl w-full">
                      <h1 
                        className="text-4xl sm:text-5xl md:text-6xl font-bold mb-6 text-center" 
                        style={getThemeStyles(findRootIndex(currentNote), level)}
                      >
                        Thank You!
                      </h1>
                      
                      <h2 className="text-xl sm:text-2xl md:text-3xl opacity-80 mb-8 text-center">
                        {currentNote.content !== "Thank You!" ? currentNote.content : currentProject.name}
                      </h2>
                      
                      {currentProject.author && (
                        <div className="mt-6 text-lg sm:text-xl opacity-70 text-center">
                          {currentProject.author}<br />
                          <span className="text-base opacity-60">{currentProject.authorTitle || ''}</span>
                        </div>
                      )}
                      
                      {currentNote.time && (
                        <div className="mt-8 bg-black/30 px-4 py-2 rounded-full">
                          <Clock className="inline mr-2" />
                          <span className="font-mono">
                            {currentNote.time}
                            {currentNote.timeBorrowed && (
                              <span className="ml-1 text-yellow-400 text-sm">(borrowed)</span>
                            )}
                          </span>
                        </div>
                      )}
                    </div>
                  </div>
                ) : (
                  // Regular slide
                  <div className="w-full h-full flex items-center justify-center p-4 md:p-8 lg:p-12">
                    <div className="w-full max-w-7xl mx-auto relative z-10">
                      {/* Ancestor path navigation */}
                      {findAncestorPath(
                        currentNote, 
                        new Map(flattenedNotes.map(note => [note.id, note]))
                      )}
                      
                      {/* Slide content */}
                      {currentNote.youtubeLink ? (
                        // YouTube slide
                        <div className="w-full">
                          <div className="mb-4">
                            <h2 
                              className="text-2xl sm:text-3xl md:text-4xl mb-2" 
                              style={getThemeStyles(findRootIndex(currentNote), level)}
                            >
                              {formatContent(currentNote.content)}
                            </h2>
                            
                            {/* YouTube embed */}
                            {renderYouTubeEmbed(currentNote.youtubeLink, { 
                              autoplay: false, 
                              startTime: currentNote.time 
                            })}
                          </div>
                          
                          {/* Audio controls below video */}
                          <div className="flex justify-end mt-3">
                            <Button
                              variant="outline"
                              size="sm"
                              onClick={(e) => {
                                e.stopPropagation();
                                setIsMuted(prev => !prev);
                              }}
                              className="text-sm"
                            >
                              {isMuted ? <VolumeX className="mr-2 h-4 w-4" /> : <Volume2 className="mr-2 h-4 w-4" />}
                              {isMuted ? 'Unmute' : 'Mute'}
                            </Button>
                          </div>
                        </div>
                      ) : currentNote.url ? (
                        // URL slide
                        <div className="w-full">
                          <div className="mb-4">
                            <h2 
                              className="text-2xl sm:text-3xl md:text-4xl mb-2" 
                              style={getThemeStyles(findRootIndex(currentNote), level)}
                            >
                              {formatContent(currentNote.content)}
                            </h2>
                          </div>
                          
                          {/* Show URL link */}
                          <div className="mt-6 flex items-center justify-center">
                            <a
                              href={currentNote.url}
                              target="_blank"
                              rel="noopener noreferrer"
                              className="flex items-center bg-white/10 hover:bg-white/20 px-4 py-3 rounded-lg text-white transition-colors border border-white/20"
                              onClick={(e) => e.stopPropagation()}
                            >
                              <ArrowRight className="mr-2 h-5 w-5" />
                              {currentNote.linkText || currentNote.url}
                            </a>
                          </div>
                          
                          {/* Display images if present */}
                          {currentNote.images && currentNote.images.length > 0 && (
                            <div className="mt-8 w-full grid grid-cols-1 gap-4">
                              {currentNote.images.slice(0, 2).map((image: string, idx: number) => (
                                <div key={idx} className={`rounded-lg overflow-hidden shadow-xl ${currentNote.images!.length === 1 ? 'aspect-[16/10] max-h-[75vh]' : 'aspect-[16/9] max-h-[40vh]'}`}>
                                  <ImageWithFallback 
                                    src={image} 
                                    alt={`Slide image ${idx + 1}`} 
                                    className="w-full h-full object-contain" 
                                  />
                                </div>
                              ))}
                            </div>
                          )}
                        </div>
                      ) : currentNote.images && currentNote.images.length > 0 ? (
                        // Image slide
                        <div className="w-full h-full flex flex-col">
                          <div className="mb-4">
                            <h2 
                              className="text-2xl sm:text-3xl md:text-4xl mb-2" 
                              style={getThemeStyles(findRootIndex(currentNote), level)}
                            >
                              {formatContent(currentNote.content)}
                            </h2>
                          </div>
                          
                          {/* Display images */}
                          <div className="w-full grid grid-cols-1 gap-4">
                            {currentNote.images.slice(0, 2).map((image: string, idx: number) => (
                              <div key={idx} className={`rounded-lg overflow-hidden shadow-xl ${currentNote.images!.length === 1 ? 'aspect-[16/10] max-h-[75vh]' : 'aspect-[16/9] max-h-[40vh]'}`}>
                                <ImageWithFallback 
                                  src={image} 
                                  alt={`Slide image ${idx + 1}`} 
                                  className="w-full h-full object-contain" 
                                />
                              </div>
                            ))}
                          </div>
                        </div>
                      ) : (
                        // Slide with text only - center content
                        <div className="w-full h-full flex flex-col items-center justify-center text-white">
                          <div 
                            className="slide-content w-full"
                            style={{
                              display: 'flex',
                              flexDirection: 'column',
                              alignItems: determineContentType(currentNote.content) === ContentType.List 
                                ? 'flex-start' 
                                : 'center',
                              justifyContent: 'center'
                            }}
                          >
                            {/* Auto-detect content type and apply appropriate styling */}
                            <div
                              className="text-content"
                              style={{
                                ...generateTypographyStyles(getTypographyStyles(
                                  determineContentType(currentNote.content),
                                  level,
                                  0 // Fixed size for all content regardless of length
                                )),
                                // No longer scaling font size to ensure consistency between slides
                                margin: determineContentType(currentNote.content) === ContentType.List 
                                  ? '0 auto 0 15%' 
                                  : '0 auto',
                              }}
                            >
                              {formatContent(currentNote.content)}
                            </div>
                            
                            {/* URL link if present */}
                            {currentNote.url && (
                              <div className="mt-6 self-center">
                                <a
                                  href={currentNote.url}
                                  target="_blank"
                                  rel="noopener noreferrer"
                                  style={{
                                    ...generateTypographyStyles(getTypographyStyles(
                                      ContentType.Regular,
                                      level,
                                      0 // Fixed size for links too
                                    )),
                                    color: 'rgba(255, 255, 255, 0.9)',
                                    display: 'flex',
                                    alignItems: 'center',
                                    // Using text decoration instead of border to avoid conflicts
                                    textDecoration: 'underline',
                                    textDecorationColor: 'rgba(255, 255, 255, 0.3)',
                                    textDecorationThickness: '1px',
                                    paddingBottom: '0.5rem',
                                  }}
                                  className="hover:text-white transition-colors"
                                >
                                  <span className="mr-2">🔗</span>
                                  {currentNote.linkText || currentNote.url}
                                </a>
                              </div>
                            )}
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
          
          {/* Minimal footer with navigation hints */}
          <div className="absolute bottom-0 left-0 right-0 text-center p-1 px-2 flex justify-between items-center bg-black/30 backdrop-blur-sm">
            <div className="w-4 sm:w-8"></div>
            <p className="text-white/40 text-[8px] sm:text-[10px] whitespace-nowrap overflow-hidden overflow-ellipsis">
              <span className="hidden sm:inline">{currentProject?.startSlogan || currentProject?.name} • </span>
              {currentSlideIndex + 1}/{flattenedNotes.length}
              <span className="hidden xs:inline"> • {isStartSlide ? 'Start' : isEndSlide ? 'End' : isOverviewSlide ? 'Overview' : ''}</span> • 
              <span className="hidden sm:inline">Click or → to advance • ← back • ↑↓ jump between sections • ESC to exit</span>
              <span className="inline sm:hidden">Tap to advance • ↑↓ jump sections</span>
            </p>
            <div className="flex items-center">
              {/* Author button - make it always visible */}
              <button 
                className="text-white/70 hover:text-white/30 opacity-100 hover:opacity-70 mr-2 text-[10px] cursor-pointer"
                onClick={() => {
                  console.log("AUTHOR BUTTON CLICKED");
                  // Navigate back to note editor
                  exitPresentation();
                }}
              >
                {currentProject?.author || "AUTHOR"}
              </button>
              <FullscreenToggle 
                buttonClassName="text-white/30 hover:text-white/70 opacity-70 hover:opacity-100"
                iconClassName="w-4 h-4"
                showTooltip={false}
              />
            </div>
          </div>
          
          {/* Debug overlay - ALWAYS VISIBLE regardless of pacing state */}
          <div className="absolute bottom-20 left-1/2 transform -translate-x-1/2 bg-black/95 p-2 rounded border border-gray-600 z-20 text-[9px] sm:text-[11px] font-mono w-[240px] sm:w-[300px]">
            <div className="grid grid-cols-[auto,1fr] gap-x-3 gap-y-1">
              <div className="text-green-400 font-semibold whitespace-nowrap">Start Time:</div>
              <div className="text-white">{(() => {
                // If we're on a timed note with a next timed note, this note is the start time
                if (currentNote?.time && pacingInfo.nextTimedNote) {
                  return currentNote.time;
                }
                // If we're on a timed note without a next timed note, we use previous timed note (if exists)
                // or the current note's time
                if (currentNote?.time && !pacingInfo.nextTimedNote) {
                  return pacingInfo.previousTimedNote?.time || currentNote.time;
                }
                // If we're between timed notes
                return pacingInfo.previousTimedNote?.time || '—';
              })()}</div>
              
              <div className="text-green-400 font-semibold whitespace-nowrap">End Time:</div>
              <div className="text-white">{(() => {
                // If we're on a timed note, find the next timed note directly
                if (currentNote?.time) {
                  // Get the next timed slide directly regardless of what pacingInfo has
                  const nextTimedSlide = getNextTimedSlide();
                  if (nextTimedSlide) {
                    return nextTimedSlide.time;
                  }
                  // If there's no next timed slide, use the current note's time
                  return currentNote.time;
                }
                // If we're between timed notes
                return pacingInfo.nextTimedNote?.time || '—';
              })()}</div>
              
              <div className="text-green-400 font-semibold whitespace-nowrap">Total Time to spend:</div>
              <div className="text-white">{(() => {
                // If we're on a timed note, directly check for the next timed note
                if (currentNote?.time) {
                  // Get the next timed slide directly
                  const nextTimedSlide = getNextTimedSlide();
                  if (nextTimedSlide) {
                    const startMin = timeToMinutes(currentNote.time || '');
                    const endMin = timeToMinutes(nextTimedSlide.time || '');
                    let totalMin = endMin - startMin;
                    if (totalMin < 0) totalMin += 24 * 60; // Adjust for time wrapping to next day
                    const hours = Math.floor(totalMin / 60);
                    const mins = Math.floor(totalMin % 60);
                    const secs = Math.round((totalMin % 1) * 60);
                    return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                  }
                  
                  // If there's no next timed slide, this is the last/only one
                  return '00:00:00'; // No time to spend
                }
                  
                // If we're between two timed notes (not on either one)
                if (pacingInfo.previousTimedNote && pacingInfo.nextTimedNote) {
                  const startMin = timeToMinutes(pacingInfo.previousTimedNote.time || '');
                  const endMin = timeToMinutes(pacingInfo.nextTimedNote.time || '');
                  let totalMin = endMin - startMin;
                  if (totalMin < 0) totalMin += 24 * 60; // Adjust for time wrapping to next day
                  const hours = Math.floor(totalMin / 60);
                  const mins = Math.floor(totalMin % 60);
                  const secs = Math.round((totalMin % 1) * 60);
                  return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                }
                  
                return '—';
              })()}</div>
              
              <div className="text-green-400 font-semibold whitespace-nowrap">Notes to spend on time:</div>
              <div className="text-white">{(() => {
                // We're on a timed slide - use direct check for next timed slide
                if (currentNote?.time) {
                  // Get next timed slide directly
                  const nextTimedSlide = getNextTimedSlide();
                  if (nextTimedSlide) {
                    const currentIndex = currentSlideIndex;
                    const nextIndex = flattenedNotes.findIndex(n => n.id === nextTimedSlide.id);
                    if (nextIndex < 0) return '—';
                    return nextIndex - currentIndex;
                  }
                  return '1'; // This is the only timed slide, count it as 1
                }
                
                // Between two timed slides
                if (pacingInfo.previousTimedNote && pacingInfo.nextTimedNote) {
                  const prevIndex = flattenedNotes.findIndex(n => n.id === pacingInfo.previousTimedNote?.id);
                  const nextIndex = flattenedNotes.findIndex(n => n.id === pacingInfo.nextTimedNote?.id);
                  if (prevIndex < 0 || nextIndex < 0) return '—';
                  return nextIndex - prevIndex;
                }
                
                return '—';
              })()}</div>
              
              <div className="text-green-400 font-semibold whitespace-nowrap">Current Note of these:</div>
              <div className="text-white">{(() => {
                // We're on a timed slide
                if (currentNote?.time) {
                  if (pacingInfo.nextTimedNote) {
                    // We're on a timed note with a next timed note
                    return '1'; // We're at the start (position 1, not 0)
                  }
                  // If we're on the last timed note with no next timed note
                  return '1'; // Consider it the first/only note in the range (position 1, not 0)
                }
                
                // Between two timed slides
                if (pacingInfo.previousTimedNote) {
                  const prevIndex = flattenedNotes.findIndex(n => n.id === pacingInfo.previousTimedNote?.id);
                  const currIndex = currentSlideIndex;
                  if (prevIndex < 0) return '—';
                  // Add 1 to convert from 0-based to 1-based position
                  return (currIndex - prevIndex + 1).toString();
                }
                
                return '—';
              })()}</div>
              
              <div className="text-green-400 font-semibold whitespace-nowrap">Result is:</div>
              <div className="text-white">{(() => {
                // Get the current time
                const now = new Date();
                const currentHour = now.getHours();
                const currentMinute = now.getMinutes();
                const currentSeconds = now.getSeconds();
                
                // Calculate current time in minutes
                const currentTimeInMinutes = currentHour * 60 + currentMinute + (currentSeconds / 60);
                
                // If we're on a timed slide
                if (currentNote?.time) {
                  // For timed slides, the result is the difference between current time and the slide's time
                  const slideTimeInMinutes = timeToMinutes(currentNote.time);
                  
                  // Calculate difference
                  let diffMinutes = currentTimeInMinutes - slideTimeInMinutes;
                  
                  // Handle crossing midnight
                  if (diffMinutes < -12 * 60) { // If negative and more than 12 hours, assume we crossed midnight
                    diffMinutes += 24 * 60;
                  } else if (diffMinutes > 12 * 60) { // If positive and more than 12 hours, assume we crossed midnight backwards
                    diffMinutes -= 24 * 60;
                  }
                  
                  // Format the time difference
                  const sign = diffMinutes >= 0 ? '+' : '-';
                  const absDiff = Math.abs(diffMinutes);
                  const hours = Math.floor(absDiff / 60);
                  const mins = Math.floor(absDiff % 60);
                  const secs = Math.round((absDiff % 1) * 60);
                  
                  return `${sign}${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                }
                
                // Between two timed notes
                if (pacingInfo.previousTimedNote?.time && pacingInfo.nextTimedNote?.time) {
                  const prevTimeInMinutes = timeToMinutes(pacingInfo.previousTimedNote.time);
                  const nextTimeInMinutes = timeToMinutes(pacingInfo.nextTimedNote.time);
                  
                  // Calculate total time span
                  let totalTimeSpan = nextTimeInMinutes - prevTimeInMinutes;
                  if (totalTimeSpan < 0) totalTimeSpan += 24 * 60; // Handle crossing midnight
                  
                  // Find slide positions
                  const prevSlideIndex = flattenedNotes.findIndex(n => n.id === pacingInfo.previousTimedNote?.id);
                  const nextSlideIndex = flattenedNotes.findIndex(n => n.id === pacingInfo.nextTimedNote?.id);
                  const currIndex = currentSlideIndex;
                  
                  if (prevSlideIndex < 0 || nextSlideIndex < 0) return "unknown";
                  
                  // Calculate total slides and our position between time points
                  const totalSlides = nextSlideIndex - prevSlideIndex;
                  if (totalSlides <= 0) return "unknown"; // Avoid division by zero
                  
                  // Calculate our linear slide progress
                  const slideProgress = (currIndex - prevSlideIndex) / totalSlides;
                  
                  // Calculate the expected time at our current position using linear interpolation
                  const expectedTimeInMinutes = prevTimeInMinutes + (totalTimeSpan * slideProgress);
                  
                  // Calculate difference between current time and expected time
                  let diffMinutes = currentTimeInMinutes - expectedTimeInMinutes;
                  
                  // Handle crossing midnight
                  if (diffMinutes < -12 * 60) diffMinutes += 24 * 60;
                  else if (diffMinutes > 12 * 60) diffMinutes -= 24 * 60;
                  
                  // Format as human-readable time difference
                  return formatTimeDifferenceHuman(diffMinutes, currentTimeInMinutes, expectedTimeInMinutes);
                }
                
                // No timed slides available for calculation
                return 'Time data unavailable';
              })()}</div>
            </div>
          </div>
          
          {/* Time tracking dots - Always show on all slides except overview slides and end slide */}
          {(!isOverviewSlide || currentNote?.time || isStartSlide) && !isEndSlide && (
            <div className="absolute bottom-10 left-1/2 transform -translate-x-1/2 flex items-center justify-center z-10">
              <div 
                className="relative h-8 sm:h-10 flex items-center justify-center"
                style={{ 
                  // Calculate width based on maximum potential offset
                  width: '140px', // 25 slides * 4px + center area
                }}
              >
                {/* White dot (current position) - always centered with 35% opacity */}
                <div 
                  className="absolute w-1.5 h-1.5 sm:w-2 sm:h-2 rounded-full bg-white/35 transition-all duration-300"
                  style={{
                    left: '50%',
                    transform: 'translateX(-50%)',
                    boxShadow: '0 0 4px rgba(255,255,255,0.3)'
                  }}
                />
                
                {/* Black dot (time adherence) - position shows ahead/behind schedule - 35% opacity 
                    Always shows on all slides, not just on timed slides */}
                <div 
                  className="absolute w-1.5 h-1.5 sm:w-2 sm:h-2 rounded-full bg-black/35 transition-all duration-300"
                  style={{
                    // Position the black dot on a smaller scale within the container
                    // 40% = maximum ahead (1 hour ahead)
                    // 50% = on time
                    // 60% = maximum behind (1 hour behind)
                    left: (() => {
                        try {
                          // Get values directly from the "Result is" field in the debug overlay
                          // This is the most reliable calculation
                          
                          // Get the current time
                          const now = new Date();
                          const currentHour = now.getHours();
                          const currentMinute = now.getMinutes();
                          const currentSeconds = now.getSeconds();
                          
                          // Calculate current time in minutes
                          const currentTimeInMinutes = currentHour * 60 + currentMinute + (currentSeconds / 60);
                          
                          // If we're on a timed slide (Current Note of these: 1)
                          if (currentNote?.time) {
                            // For timed slides, the result is the difference between current time and the slide's time
                            const slideTimeInMinutes = timeToMinutes(currentNote.time);
                            
                            // Calculate difference
                            let diffMinutes = currentTimeInMinutes - slideTimeInMinutes;
                            
                            // Handle crossing midnight
                            if (diffMinutes < -12 * 60) diffMinutes += 24 * 60;
                            else if (diffMinutes > 12 * 60) diffMinutes -= 24 * 60;
                            
                            // Cap diffMinutes to -60..60 range
                            const timePosition = Math.max(-60, Math.min(60, diffMinutes));
                            // Map from -60..60 to 40%..60% (with 0 = 50%)
                            const percentPosition = 50 + ((timePosition / 60) * 10);
                            return `${percentPosition}%`;
                          }
                          
                          // Between two timed notes (exactly same calculation from the debug "Result is" field)
                          if (pacingInfo.previousTimedNote?.time && pacingInfo.nextTimedNote?.time) {
                            const prevTimeInMinutes = timeToMinutes(pacingInfo.previousTimedNote.time);
                            const nextTimeInMinutes = timeToMinutes(pacingInfo.nextTimedNote.time);
                            
                            // Calculate total time span
                            let totalTimeSpan = nextTimeInMinutes - prevTimeInMinutes;
                            if (totalTimeSpan < 0) totalTimeSpan += 24 * 60; // Handle crossing midnight
                            
                            // Find slide positions
                            const prevSlideIndex = flattenedNotes.findIndex(n => n.id === pacingInfo.previousTimedNote?.id);
                            const nextSlideIndex = flattenedNotes.findIndex(n => n.id === pacingInfo.nextTimedNote?.id);
                            
                            if (prevSlideIndex < 0 || nextSlideIndex < 0) return "50%";
                            
                            // Calculate total slides and our position
                            const totalSlides = nextSlideIndex - prevSlideIndex;
                            if (totalSlides <= 1) return "50%"; // Avoid division by zero
                            
                            // Calculate our position (fraction) between the two timed slides
                            const slideProgress = (currentSlideIndex - prevSlideIndex) / totalSlides;
                            
                            // Calculate the expected time at our position using linear interpolation
                            const expectedTimeInMinutes = prevTimeInMinutes + (totalTimeSpan * slideProgress);
                            
                            // Calculate difference between current time and expected time
                            let diffMinutes = currentTimeInMinutes - expectedTimeInMinutes;
                            
                            // Handle crossing midnight
                            if (diffMinutes < -12 * 60) diffMinutes += 24 * 60;
                            else if (diffMinutes > 12 * 60) diffMinutes -= 24 * 60;
                            
                            // Cap diffMinutes to -60..60 range
                            const timePosition = Math.max(-60, Math.min(60, diffMinutes));
                            // Map from -60..60 to 40%..60% (with 0 = 50%)
                            const percentPosition = 50 + ((timePosition / 60) * 10);
                            return `${percentPosition}%`;
                          }
                          
                          // Default: If we can't calculate, use center position
                          return "50%";
                        } catch (err) {
                          console.error("Error calculating dot position:", err);
                          return "50%"; // Default to center in case of error
                        }
                      })(),
                      transform: 'translateX(-50%)',
                      boxShadow: '0 0 4px rgba(0,0,0,0.3)'
                    }}
                  />
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
